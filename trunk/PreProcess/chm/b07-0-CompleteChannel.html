<html><head><title>The CompleteChannel class</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>CompleteChannel-class(PreProcess)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   CompleteChannel-class">
<param name="keyword" value="R:   CompleteChannel">
<param name="keyword" value="R:   print,CompleteChannel-method">
<param name="keyword" value="R:   summary,CompleteChannel-method">
<param name="keyword" value="R:   channelize,CompleteChannel-method">
<param name="keyword" value="R:   plot,CompleteChannel,missing-method">
<param name="keyword" value="R:   image,CompleteChannel-method">
<param name="keyword" value="R:   as.data.frame,CompleteChannel-method">
<param name="keyword" value="R:   analyze,CompleteChannel-method">
<param name="keyword" value="R:   process,CompleteChannel,Processor-method">
<param name="keyword" value="R:   PROC.BACKGROUND">
<param name="keyword" value="R:   PROC.SIGNAL">
<param name="keyword" value="R:   PROC.CORRECTED.SIGNAL">
<param name="keyword" value="R:   PROC.NEG.CORRECTED.SIGNAL">
<param name="keyword" value="R:   PROC.SD.SIGNAL">
<param name="keyword" value="R:   PROC.SIGNAL.TO.NOISE">
<param name="keyword" value=" The CompleteChannel class">
</object>


<h2>The CompleteChannel class</h2>


<h3>Description</h3>

<p>
An object of the CompleteChannel class represents one channel (red or
green) of a two-color fluorescence microarray experiment.
Alternatively, it can also represent the entirety of a radioactive
microarray experiment.  Affymetrix experiments produce data with a
somewhat different structure because they use multiple probes for each
target gene.
</p>


<h3>Usage</h3>

<pre>
CompleteChannel(name, type, data)
## S4 method for signature 'CompleteChannel':
print(x, ...)
## S4 method for signature 'CompleteChannel':
summary(object, ...)
## S4 method for signature 'CompleteChannel':
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'CompleteChannel, missing':
plot(x, useLog=FALSE, ...)
## S4 method for signature 'CompleteChannel':
image(x, ...)
## S4 method for signature 'CompleteChannel':
analyze(object, useLog=FALSE, ...)
## S4 method for signature 'CompleteChannel, Processor':
process(object, action, parameter)
## S4 method for signature 'CompleteChannel':
channelize(object)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>name</code></td>
<td>
A string containing the name of the object</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
A <code><a href="b03-0-ChannelType.html">ChannelType</a></code> object</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
A data frame. For the pre-defined ``extraction''
processors to work correctly, this should include columns called
<code>vol</code>, <code>bkgd</code>, <code>svol</code>, <code>SD</code>, and <code>SN</code>.</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
A <code>CompleteChannel</code> object</td></tr>
<tr valign="top"><td><code>object</code></td>
<td>
A <code>CompleteChannel</code> object</td></tr>
<tr valign="top"><td><code>useLog</code></td>
<td>
A logical value</td></tr>
<tr valign="top"><td><code>action</code></td>
<td>
A <code>Processor</code> object used to process a
<code>CompleteChannel</code>. </td></tr>
<tr valign="top"><td><code>parameter</code></td>
<td>
Any object that makes sense as a parameter to the
function represented by the <code>Processor</code> <code>action</code></td></tr>
<tr valign="top"><td><code>row.names</code></td>
<td>
See <code><a onclick="findlink('base', 'as.data.frame.html')" style="text-decoration: underline; color: blue; cursor: hand">as.data.frame</a></code></td></tr>
<tr valign="top"><td><code>optional</code></td>
<td>
See <code><a onclick="findlink('base', 'as.data.frame.html')" style="text-decoration: underline; color: blue; cursor: hand">as.data.frame</a></code></td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Additional arguments are as in the underlying generic methods.</td></tr>
</table>

<h3>Details</h3>

<p>
The
names come from the default column names in the ArrayVision software
package used at M.D. Anderson for quantifying glass or nylon
microarrays. Column names used by other software packages should be
mapped to these.
</p>


<h3>Value</h3>

<p>
The <code>analyze</code> method returns a list of three density functions.
<br>
The return value of the <code>process</code> function depends on the
<code><a href="b05-0-Processor.html">Processor</a></code> performing the action, but is typically a
<code><a href="b04-0-Channel.html">Channel</a></code> object.
<br>
Graphical methods invisibly return the object on which they were
invoked.</p>

<h3>Slots</h3>

<dl>
<dt><code>name</code>:</dt><dd>A string containing the name of the object</dd>
<dt><code>type</code>:</dt><dd>A <code><a href="b03-0-ChannelType.html">ChannelType</a></code> object</dd>
<dt><code>data</code>:</dt><dd>A data frame</dd>
<dt><code>history</code>:</dt><dd>A list that keeps a record of the calls used
to produce this object </dd>
</dl>

<h3>Methods</h3>

<dl>
<dt>print(x, ...)</dt><dd>Print all the data on the object. Since
this includes the data frame, you rarely want to do this.</dd>
<dt>summary(object, ...)</dt><dd>Write out a summary of the object.</dd>
<dt>as.data.frame(x,row.names=NULL, optional=FALSE)</dt><dd>Convert the
<code>CompleteChannel</code> object into a data frame. As you might
expect, this simply returns the data frame in the <code>data</code> slot
of the object.</dd>
<dt>plot(x, useLog=FALSE, ...)</dt><dd>Produces three estimated density
plots: one for the signal, one for the background, and one for
the background-corrected signal. Additional graphical parameters
are passed along. The logical flag <code>useLog</code> determines
whether the data are log-transformed before estimating and
plotting densities.</dd> 
<dt>analyze(object, useLog=FALSE, ...)</dt><dd>This method computes the
estimated probability density functions for the three data
components (signal, background, and background-corrected signal),
and returns them as a list. </dd>
<dt>image(object, ...)</dt><dd>Uses the image method for
<code><a href="b04-0-Channel.html">Channel</a></code> objects to produce geographically aligned
images of the log-transformed intensity and background estimates.</dd>
<dt>channelize(object)</dt><dd>A string giving the name of the class of a
channel that is produced when you process a <code>CompleteChannel</code>
object.</dd>
<dt>process(object, action, parameter=NULL)</dt><dd>Use the
<code>Processor</code> <code>action</code> to process the
<code>CompleteChannel</code> <code>object</code>. Returns an object of the
class described by <code>channelize</code>, which defaults to
<code>Channel</code>.</dd>

<p>
</dl>

<h3>Pre-defined Processors</h3>

<p>
The library comes with several <code>Processor</code> objects already
defined; each one takes a <code>CompleteChannel</code> as input, extracts a
single value per spot, and produces a <code>Channel</code> as output.
<dl>
<dt><code>PROC.BACKGROUND</code></dt><dd>Extract the vector of local
background measurements.</dd>
<dt><code>PROC.SIGNAL</code></dt><dd>Extract the vector of foreground signal
intensity measurements. </dd>
<dt><code>PROC.CORRECTED.SIGNAL</code></dt><dd>Extract the vector of
background-corrected signal measurements. Note that many software
packages automatically truncate these value below at zero, so this
need not be the same as SIGNAL - BACKGROUND.</dd>
<dt><code>PROC.NEG.CORRECTED.SIGNAL</code></dt><dd>Extract the vector of
background-corrected signal intensities by subtracting the local
background from the observed foreground, without truncation.</dd>
<dt><code>PROC.SD.SIGNAL</code></dt><dd>Extract the vector of pixel standard
deviations of the signal intensity.</dd>
<dt><code>PROC.SIGNAL.TO.NOISE</code></dt><dd>Extract the vector of
signal-to-noise ratios, defined as CORRECTED.SIGNAL divided by the
standard deviation of the background pixels.</dd>
</dl>

<h3>Author(s)</h3>

<p>
Kevin R. Coombes &lt;kcoombes@mdanderson.org&gt;
</p>


<h3>See Also</h3>

<p>
<code><a href="b00-0-generics.html">process</a></code>, <code><a href="b05-0-Processor.html">Processor</a></code>,
<code><a href="b06-0-Pipeline.html">Pipeline</a></code>, <code><a href="b04-0-Channel.html">Channel</a></code>, <code><a onclick="findlink('base', 'as.data.frame.html')" style="text-decoration: underline; color: blue; cursor: hand">as.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre>
# simulate a complete channel object

v &lt;- rexp(10000, 1/1000)
b &lt;- rnorm(10000, 60, 6)
s &lt;- sapply(v-b, function(x) {max(0, x)})
ct &lt;- ChannelType('user', 'random', 100, 100, 'fake')
x &lt;- CompleteChannel(name='fraud', type=ct,
                      data=data.frame(vol=v, bkgd=b, svol=s))
rm(v, b, s, ct)

summary(x)

opar &lt;- par(mfrow=c(2,3))
plot(x)
plot(x, main='Log Scale', useLog=TRUE)
par(opar)

opar &lt;- par(mfrow=c(2,1))
image(x)
par(opar)

b &lt;- process(x, PROC.NEG.CORRECTED.SIGNAL)
summary(b)

q &lt;- process(b, PIPELINE.STANDARD)
summary(q)

q &lt;- process(x, PIPELINE.MDACC.DEFAULT)
summary(q)

# cleanup
rm(x, b, q, opar)
</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>PreProcess</em> version 2.7.0 <a href="00Index.html">Index]</a></div>

</body></html>
